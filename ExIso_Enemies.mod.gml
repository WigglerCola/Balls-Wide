#define init
//Roomba Sprites
global.sprRoomba					= sprite_add("sprites/enemies/roomba/sprRoomba.png", 1, 8, 8)
global.sprRoombaHurt				= sprite_add("sprites/enemies/roomba/sprRoombaHurt.png", 3, 8, 8)
global.sprRoombaDead				= sprite_add("sprites/enemies/roomba/sprRoombaDead.png", 7, 8, 8)
//Labs MicroMissile Sprites
global.mskLabsRocket				= sprite_add("sprites/enemies/projectiles/mskLabsRocket.png",1,6,4)
global.sprLabsRocket				= sprite_add("sprites/enemies/projectiles/sprLabsRocket.png",1,6,4)
global.sprLabsRocketFlame			= sprite_add("sprites/enemies/projectiles/sprLabsRocketFlame.png",3,15,3)
global.sprLabsRocketTrail			= sprite_add("sprites/enemies/projectiles/sprLabsRocketTrail.png",3,4,4)
global.sprLabsRocketExplosion		= sprite_add("sprites/enemies/projectiles/sprLabsRocketExplosion.png",7,12,12)
//Roller Turret Sprites
global.sprRollerTurretIdle			= sprite_add("sprites/enemies/rollerturret/sprRollerTurretIdle.png", 5, 24, 16)
global.sprRollerTurretWalk			= sprite_add("sprites/enemies/rollerturret/sprRollerTurretWalk.png", 6, 24, 16)
global.sprRollerTurretHurt			= sprite_add("sprites/enemies/rollerturret/sprRollerTurretHurt.png", 3, 24, 16)
global.sprRollerTurretDead			= sprite_add("sprites/enemies/rollerturret/sprRollerTurretDead.png", 6, 24, 16)
global.sprRollerTurretFire			= sprite_add("sprites/enemies/rollerturret/sprRollerTurretFire.png", 5, 24, 16)
global.sprRollerTurretRoll			= sprite_add("sprites/enemies/rollerturret/sprRollerTurretRoll.png", 3, 24, 6)
//Swarm Bot Sprites
global.sprSwarmBotIdle				= sprite_add("sprites/enemies/swarmbot/sprSwarmBotIdle.png", 5, 15, 16)
global.sprSwarmBotWalk				= sprite_add("sprites/enemies/swarmbot/sprSwarmBotWalk.png", 6, 15, 16)
global.sprSwarmBotHurt				= sprite_add("sprites/enemies/swarmbot/sprSwarmBotHurt.png", 3, 15, 16)
global.sprSwarmBotDead				= sprite_add("sprites/enemies/swarmbot/sprSwarmBotDead.png", 6, 15, 16)
//Engineer Sprites
global.sprEngineerIdle				= sprite_add("sprites/enemies/engineer/sprEngineerIdle.png", 4, 16, 20)
global.sprEngineerWalk				= sprite_add("sprites/enemies/engineer/sprEngineerWalk.png", 6, 16, 20)
global.sprEngineerHurt				= sprite_add("sprites/enemies/engineer/sprEngineerHurt.png", 3, 16, 20)
global.sprEngineerDead				= sprite_add("sprites/enemies/engineer/sprEngineerDead.png", 6, 16, 20)
global.sprEngineerCannon			= sprite_add("sprites/enemies/engineer/sprEngineerCannon.png", 1, 6, 0)
global.sprEngineerWrench			= sprite_add("sprites/enemies/engineer/sprEngineerWrench.png", 1, 6, 0)
global.sprSwarmBotFired 			= sprite_add("sprites/enemies/projectiles/sprSwarmBotFired.png", 1, 7, 5)
//Cremator Sprites
global.shdCremator					= sprite_add("sprites/enemies/cremator/shdCremator.png", 1, 12, 12)
global.sprCrematorIdle				= sprite_add("sprites/enemies/cremator/sprCrematorIdle.png", 1, 16, 11)
//Raven Amalgam Sprites
global.sprRavenAmalgamIdle			= sprite_add("sprites/enemies/ravenamalgam/sprRavenAmalgamIdle.png", 10, 16, 16)
global.sprRavenAmalgamWalk			= sprite_add("sprites/enemies/ravenamalgam/sprRavenAmalgamWalk.png", 6, 16, 16)
global.sprRavenAmalgamCharge		= sprite_add("sprites/enemies/ravenamalgam/sprRavenAmalgamCharge.png", 10, 24, 24)
//Splitter Guardian Sprites
global.shdGupGuardian				= sprite_add("sprites/enemies/gupguardian/shdGupGuardian.png", 1, 32, 48)
global.mskGupGuardian				= sprite_add("sprites/enemies/gupguardian/mskGupGuardian.png", 1, 32, 32)
global.sprGupGuardianIdle			= sprite_add("sprites/enemies/gupguardian/sprGupGuardianIdle.png", 5, 32, 32)
global.sprGupGuardianWalk			= sprite_add("sprites/enemies/gupguardian/sprGupGuardianWalk.png", 8, 32, 32)
global.sprGupGuardianHurt			= sprite_add("sprites/enemies/gupguardian/sprGupGuardianHurt.png", 3, 32, 32)
global.sprGupGuardianDead			= sprite_add("sprites/enemies/gupguardian/sprGupGuardianDead.png", 8, 32, 32)
global.sprGeepGuardianIdle			= sprite_add("sprites/enemies/gupguardian/sprGeepGuardianIdle.png", 5, 24, 24)
global.sprGeepGuardianWalk			= sprite_add("sprites/enemies/gupguardian/sprGeepGuardianWalk.png", 8, 24, 24)
global.sprGeepGuardianHurt			= sprite_add("sprites/enemies/gupguardian/sprGeepGuardianHurt.png", 3, 24, 24)
global.sprGeepGuardianDead			= sprite_add("sprites/enemies/gupguardian/sprGeepGuardianDead.png", 8, 32, 32)
global.sprGipGuardianIdle			= sprite_add("sprites/enemies/gupguardian/sprGipGuardianIdle.png", 5, 15, 19)
global.sprGipGuardianWalk			= sprite_add("sprites/enemies/gupguardian/sprGipGuardianWalk.png", 8, 15, 19)
global.sprGipGuardianHurt			= sprite_add("sprites/enemies/gupguardian/sprGipGuardianHurt.png", 3, 15, 19)
global.sprGipGuardianDead			= sprite_add("sprites/enemies/gupguardian/sprGipGuardianDead.png", 7, 24, 24)
//Enforcer
global.sprPopoBubblesIdle			= sprite_add("sprites/enemies/popobubbles/sprPopoBubblesIdle.png", 15, 12, 12)
global.sprPopoBubblesWalk			= sprite_add("sprites/enemies/popobubbles/sprPopoBubblesWalk.png", 6, 12, 12)
global.sprPopoBubblesBaton			= sprite_add("sprites/enemies/popobubbles/sprBaton.png", 1, 5, 6)
global.sprPopoBubbleProjectile		= sprite_add("sprites/enemies/projectiles/sprPopoBubbleProjectile.png", 4, 8, 8)
//PopoExploder
global.sprPopoExploder				= sprite_add("sprites/enemies/popoexploder/sprPopoExploder.png", 8, 16, 16)
global.sprPopoExploderHurt			= sprite_add("sprites/enemies/popoexploder/sprPopoExploderHurt.png", 3, 16, 16)
global.sprPopoExploderDead			= sprite_add("sprites/enemies/popoexploder/sprPopoExploderDead.png", 6, 16, 16)
global.sprPopoExploderBlink			= sprite_add("sprites/enemies/popoexploder/sprPopoExploderBlink.png", 10, 16, 16)
//Projectiles/Effects
global.sprWhiteSmoke				= sprite_add("sprites/particles/sprWhiteSmoke.png",5,12,12)

#macro current_frame_active frac(current_frame) < current_time_scale

// LIB:
while(!mod_exists("mod", "lib")){wait(1);}
script_ref_call(["mod", "lib", "getRef"], "mod", mod_current, "scr");

#macro  scr																						global.scr
#macro  call																					script_ref_call


//remove this step later, this is for dev stuff
//#define step 
//    if button_pressed(0,"horn"){
//	repeat(1){
//	Voltergeist_create(mouse_x,mouse_y);
//	}}

//#region ENEMIES
//#region ROBOCENTER ENEMIES
	//Swarmbot:
#define Swarmbot_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Swarmbot"
    	
        //Visuals:
        spr_idle = global.sprSwarmBotIdle;
		spr_walk = global.sprSwarmBotWalk;
		spr_hurt = global.sprSwarmBotHurt; 
		spr_dead = global.sprSwarmBotDead;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "SWARMBOT"]
        spr_shadow      = shd24;	
        spr_shadow_y    = 0.5;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndHydrantBreak;
        snd_dead = sndPlantPotBreak;
        
        //Vars:
        mask_index    = mskFreak;
        direction     = random(360);
        maxhealth     = 8;
       	my_health     = maxhealth;
        raddrop       = 2;
        normalspeed   = 2.5; //maxspeed when no target
        targetspeed  = 4; //maxspeed when target
        maxspeed      = 2;
        walkspeed     = maxspeed;
        canmelee      = 1;
        meleedamage   = 2;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        
        //Alarms:
        alarm1 = 20 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(Swarmbot_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = Swarmbot_death;
        on_alrm1 = script_ref_create(Swarmbot_alrm1);
        
        return self;
}
#define Swarmbot_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
	else sprite_index = enemy_sprite;

	if instance_exists(target){
	if  target_visible	maxspeed = targetspeed
	if !target_visible  maxspeed = normalspeed
	}
	
		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;

#define Swarmbot_alrm1
	alarm1 = 10 + irandom(5);
	
	if(enemy_target(x, y) and target_visible) {
			direction = point_direction(x,y,target.x,target.y)
		enemy_walk(direction, alarm1);
	}
	
	else {
		if(chance(1, 2)) {
		direction = random(360);
		enemy_walk(direction, alarm1);
		}
	}
	
#define Swarmbot_death
pickup_drop(7, 0, 1);
	//Engineer:
#define Engineer_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Engineer"
    	
        //Visuals:
        spr_idle = global.sprEngineerIdle;
		spr_walk = global.sprEngineerWalk;
		spr_hurt = global.sprEngineerHurt; 
		spr_dead = global.sprEngineerDead;
		spr_weap = global.sprEngineerCannon;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "ENGINEER"]
        spr_shadow      = shd24;	
        spr_shadow_y    = 1;
        nts_color_blood = [c_red, make_color_rgb(134, 44, 35)]
        
        //Sounds:
        snd_hurt = sndNecromancerHurt;
        snd_dead = sndNecromancerDead;
        
        //Vars:
        mask_index    = mskBandit;
        direction     = random(360);
        maxhealth     = 6;
       	my_health     = maxhealth;
        raddrop       = 8;
        maxspeed      = 2.5;
        walkspeed     = maxspeed;
        canmelee      = 0;
        meleedamage   = 0;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        panic         = 0;
        walk          = 0;
        gunangle      = 180;
        panicrange    = 60;
    	wepangle      = 110;
        
        //Alarms:
        alarm1 = 40 + irandom(40);

        //Scripts:
        on_step  = script_ref_create(Engineer_step);
        on_draw  = Engineer_draw;
        on_hurt  = Enemy_hurt;
        on_death = StandardDrops;
        on_alrm1 = script_ref_create(Engineer_alrm1);
        
        return self;
}

#define Engineer_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
	else sprite_index = enemy_sprite;
	
		//Panic Switch
	if distance_to_object(target) < panicrange  and target_visible   { panic = 1 }
	if distance_to_object(target) > panicrange  					 { panic = 0 }
	
		//Panic Wep Switch
	if panic = 1 { spr_weap = global.sprEngineerWrench}
	if panic = 0 { spr_weap = global.sprEngineerCannon} 
	
		//Panic Particles
	if panic = 1 and random (random(5) < current_time_scale){instance_create(x,y,Sweat)}
	
		//Use Your Eyes:
	right = (gunangle + 270) mod 360 > 180 ? 1 : -1;

#define Engineer_alrm1
	alarm1 = 40 + irandom(20);
	
				//Fire Swarmbots when not Panicked:
			if(enemy_target(x, y) and target_visible and panic = 0) {
				
				alarm1 = 65 + irandom(20);
				direction = -target_direction + orandom(20);
				gunangle = point_direction(x,y,target.x,target.y)
	
				//Swarmbot Projectile:
			with instance_create((x+lengthdir_x(0, gunangle)),(y+lengthdir_y(0, gunangle)),CustomEnemy){
				hitid = [global.sprEngineerIdle,"ENGINEER"]
				sprite_index = global.sprSwarmBotFired;
				mask_index = mskFreak;
				maxspeed	 = 10;
				canmelee	 = true;
				meleedamage  = 2;
				speed		 = maxspeed
				team		 = other.team;
				direction	 = other.gunangle+random_range(-25,25);
				creator      = other;
				image_angle  = direction;
				//GetReal:
				on_step      = EngineerProjectile_step;
				on_wall      = nothing;
				on_destroy   = EngineerProjectile_destroy;
				}
				
			wkick += 8
			sound_play_pitchvol(sndGrenadeRifle,random_range(1.3,1.5),0.8)
			
				//Smoke:
			repeat(5)
			with instance_create(x+lengthdir_x(15,gunangle),y+lengthdir_y(15,gunangle),Smoke){
				sprite_index = global.sprWhiteSmoke;
				image_xscale = 0.2 + random_range(0.1,0.5);
				image_yscale = image_xscale;
				motion_add(other.direction+random_range(-10,10),1+random(2)) 
				}
			}
		
			//Swing Wrench when Panicked:
		if(enemy_target(x, y) and target_visible and panic = 1) {
			alarm1 = 70 + irandom(20);
			direction = -target_direction + orandom(20);
			enemy_walk(direction, alarm1 - 10);
			if(chance(1, 2)) {
			alrm1 = 50 + random(20)
		if instance_exists(self){
			
				//Warning:
			instance_create(x,y,AssassinNotice)
			wait(8);
			if !instance_exists(self){ exit;}
			
			gunangle = point_direction(x,y,target.x,target.y)
			
				//Slash:
		with instance_create((x+lengthdir_x(1, gunangle)),(y+lengthdir_y(1, gunangle)),EnemySlash){
			sound_play(sndAssassinAttack)
			sound_play_pitch(sndWrench, 0.7 + random(0.3));
			hitid = [global.sprEngineerIdle,"ENGINEER"]
			damage	    = 3;
			speed	    = 2;
			team        = other.team;
			direction   = other.gunangle+random_range(-15,15);
			creator     = other;
			image_angle = direction;
			}
				
			motion_add(gunangle, 3.5);
			
				}
			}
		}
		
		//Go For a Stroll:
	else if(chance(1, 3)) {
		direction = random(360);
		enemy_walk(direction, alarm1 - 20);
	}
	
	enemy_face(direction);
	
#define Engineer_draw
if panic = 0{
if gunangle < 180{ draw_sprite_ext(spr_weap,0,x + lengthdir_x(-wkick,gunangle), y + lengthdir_y(-wkick, gunangle), 1, right, gunangle, image_blend, image_alpha);} draw_sprite_ext(sprite_index,image_index,x,y,image_xscale * right, image_yscale, image_angle, image_blend, image_alpha); if gunangle >= 180{ draw_sprite_ext(spr_weap,0,x + lengthdir_x(-wkick,gunangle), y + lengthdir_y(-wkick, gunangle), 1, right, gunangle, image_blend, image_alpha);}	
}
if panic = 1{
if(gunangle <= 180) draw_weapon(spr_weap, 0, x, y, gunangle, wepangle, wkick, 1, image_blend, image_alpha); image_xscale *= right; draw_self(); image_xscale /= right; if(gunangle >  180) draw_weapon(spr_weap, 0, x, y, gunangle, wepangle, wkick, 1, image_blend, image_alpha);	
}
	//Roller Turret:
#define RollerTurret_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Roller Turret"
    	
        //Visuals:
        spr_idle = global.sprRollerTurretIdle;
		spr_walk = global.sprRollerTurretWalk;
		spr_hurt = global.sprRollerTurretHurt; 
		spr_dead = global.sprRollerTurretDead;
		spr_roll = global.sprRollerTurretRoll;
		spr_fire = global.sprRollerTurretFire;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "ROLLER TURRET"]
        spr_shadow      = shd64;	
        spr_shadow_y    = -1;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndTurretHurt;
        snd_dead = sndTurretDead;
        
        //Vars:
        mask_index    = mskBigMaggot;
        direction     = random(360);
        maxhealth     = 30;
       	my_health     = maxhealth;
        raddrop       = 4;
        maxspeed      = 1;
        normalspeed   = 1;
        rollerspeed   = 4;
        walkspeed     = maxspeed;
        canmelee      = 0;
        meleedamage   = 0;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        rolling       = 0;
        fireanim      = 0;
        
        //Alarms:
        alarm1 = 40 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(RollerTurret_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = StandardDrops;
        on_alrm1 = script_ref_create(RollerTurret_alrm1);
        
        return self;
}

#define RollerTurret_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
	if rolling > 0 { maxspeed = rollerspeed }
	if rolling = 0 { maxspeed = normalspeed }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
	 // Animate:
	  if fireanim > 0{
			sprite_index = spr_fire
		}
	  if rolling > 0{
			sprite_index = spr_roll
		}
	if(anim_end){
		 //Checks if not firing or rolling
			if fireanim = 0 && rolling = 0 {
		sprite_index = (speed > 0) ? spr_walk : spr_idle;
	}}
	
	//RollerTurret var counters + rollschmoove
	if fireanim > 0 { fireanim -= current_time_scale }
	if rolling  > 0 { rolling  -= current_time_scale motion_add(direction, 0.8) instance_create(x,y,Dust) }
		
		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;

#define RollerTurret_alrm1
	alarm1 = 40 + irandom(20);
	
				//Fires bullets when not rollin:
			if(enemy_target(x, y) and target_visible) and target_distance < 130 and rolling = 0{
				
				// Noooo mooore instasniping!
			wait(random_range(10,15)); 
			if !instance_exists(self){ exit;}
			if !target_visible { exit;}
				
				alarm1 = 60 + irandom(40);
				direction = -target_direction + orandom(20);
				gunangle = point_direction(x,y,target.x,target.y)
	
				//Boolet:
			fireanim = 10;
			repeat(5){
			if !instance_exists(self){ exit;}
			with instance_create((x+lengthdir_x(1, gunangle)),(y+lengthdir_y(1, gunangle)),EnemyBullet1){ 
			
			sound_play_pitchvol(sndTurretFire,random_range(1,1.3),1)
				hitid      = other.hitid;
				damage	    = 3;
				speed	    = 7;
				team	    = other.team
				direction   = other.gunangle+random_range(-4,4);
				creator     = other;
				image_angle = direction;
					} wait(2.5);
				}
			}

		//IM ABSOLUTELY LIVID AND IM GOING TO ROLL RIGHT INTO YOU:
	if !instance_exists(self){ exit;}
	if(enemy_target(x, y) and target_visible) and target_distance > 130 and fireanim = 0{
	direction = target_direction;
	rolling = round(target_distance/6);
	alarm1 = 60 + irandom(40);
//	sound_play_pitchvol(sndWolfRoll,random_range(0.8,1.2),1)
	call(scr.sound_play_at, x, y, sndWolfRoll, 0.8 + random(0.4), 1, 48, 1);  // Sound
	}
	
		//Go For a (St)roll:
	else if(chance(1, 6)) {
		direction = random(360);
		rolling = 25+irandom(15);
//		sound_play_pitchvol(sndWolfRoll,random_range(0.8,1.2),1)
	call(scr.sound_play_at, x, y, sndWolfRoll, 0.8 + random(0.4), 1, 48, 1);  // Sound
	}
	
	//Missile Drone:
#define MissileDrone_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Missile Drone"
    	
        //Visuals:
        spr_idle = sprLilHunter;
		spr_walk = sprLilHunterWalk;
		spr_hurt = sprLilHunterHurt; 
		spr_dead = sprLilHunterDead;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "MISSILE DRONE"]
        spr_shadow      = shd64;	
        spr_shadow_y    = -1;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndTurretHurt;
        snd_dead = sndTurretDead;
        
        //Vars:
        mask_index    = mskBigMaggot;
        direction     = random(360);
        maxhealth     = 35;
       	my_health     = maxhealth;
        raddrop       = 4;
        maxspeed      = 2;
        walkspeed     = maxspeed;
        canmelee      = 0;
        meleedamage   = 0;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        gunangle	  = random(360);
        laserangle	  = 0;
        
        //Alarms:
        alarm1 = 30 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(MissileDrone_step);
        on_draw  = MissileDrone_draw;
        on_hurt  = Enemy_hurt;
        on_death = StandardDrops;
        on_alrm1 = script_ref_create(MissileDrone_alrm1);
        on_alrm2 = script_ref_create(MissileDrone_alrm2);
        
        return self;
}

#define MissileDrone_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;
	if("on_alrm2" in self and alarm2_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }

		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;
	
		// Make Lasersight have cool spread animation
	if laserangle < 10 { laserangle += 1; }
	
		if(alarm2_run) exit;
	
	if(alarm2 > 6) {
		if(enemy_target(x, y)) {
			gunangle = target_direction;
			direction = gunangle;
			enemy_face(gunangle);
		}
	}
	

#define MissileDrone_alrm1
	alarm1 = 40 + irandom(30);

	if(enemy_target(x, y) and target_visible) {
		enemy_look(target_direction);
		
			// Move Away From Target:
		if(target_distance < 64){
			alarm1 = 30 + irandom(15);
			enemy_walk(target_direction - 180 + orandom(30), alarm1 - 10);
		}
		
			// Move Towards target when too far away
		if(target_distance > 224){
			alarm1 = 30 + irandom(15);
			enemy_walk(target_direction + orandom(30), alarm1 - 10);
		}
			 // If in range:
		if(target_distance < 224){
			 // Attack:
			 // Not too close!
			if(chance(1, 4) and (target_distance > 48)){
				alarm1 = 45 + irandom(20);
				
				// ENGAGE LASER:!
				alarm2 = 50;
				laserangle = 0;
				
				sound_play_pitch(sndSniperTarget, 0.5 + random(0.3));
				sound_play_pitch(sndIDPDNadeAlmost, 0.5 + random(0.3));
				motion_add(gunangle, 2);
			}
		}	
				
				if chance(1,4) and alarm2 <= 0{
				alarm1 = 30 + irandom(15);
				enemy_walk(random(360), alarm1 - 10);
				}
			
	}
	
	 // Wander Around Town:
	else{
		if(chance(1, 5)){
		direction = random(360);
		enemy_walk(direction, alarm1);
		}
	}

#define MissileDrone_alrm2
		repeat(6) {
			if !instance_exists(self){ exit;}
			with LabsRocket_create(x,y){
				sound_play_pitchvol(sndRocket,1.2,0.8)
				team	    = other.team
				direction   = other.gunangle + random_range(-10,10)
				image_angle = direction
			}
			wait(0.5)
		}
				
#define MissileDrone_draw
	if(alarm2) {
		draw_set_color(make_color_rgb(250, 54, 0));
		//call(scr.draw_lasersight, x, y, gunangle, 1000,2);
		call(scr.draw_lasersight, x, y, gunangle + laserangle, 1000,1);
		call(scr.draw_lasersight, x, y, gunangle - laserangle, 1000,1);
		draw_set_alpha(0.5)
		call(scr.draw_lasersight, x, y, gunangle + laserangle/1.2, 1000,1);
		call(scr.draw_lasersight, x, y, gunangle - laserangle/1.2, 1000,1);
		draw_set_color(c_white);
		draw_set_alpha(1)
	}

draw_sprite_ext(sprite_index,image_index,x,y,image_xscale * right, image_yscale, image_angle, image_blend, image_alpha);

//#region GRAVEYARD ENEMIES


	//Voltergeist:
#define Voltergeist_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Voltergeist"
    	
        //Visuals:
        spr_idle = sprNightCactus;
		spr_walk = sprCactus;
		spr_hurt = sprBanditHurt; 
		spr_dead = sprPopoRevive;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "VOLTERGEIST"]
        nts_color_blood = [make_color_rgb(255, 255, 0), c_yellow]
        
        //Sounds:
        snd_hurt = sndTurretHurt;
        snd_dead = sndTurretDead;
        
        //Vars:
        mask_index    = mskBigMaggot;
        direction     = random(360);
        maxhealth     = 20;
       	my_health     = maxhealth;
        raddrop       = 3;
        maxspeed      = 3.5;
        walkspeed     = maxspeed;
        gunangle      = 180;
        canmelee      = 0;
        meleedamage   = 0;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        possessions	  = 0;
        possesionmax  = 3;
        possessing    = false;
        possesstarget        = 0;
        possesstargetvisible = 0;
        
        //Alarms:
        alarm1 = 40 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(Voltergeist_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = Voltergeist_death;
        on_alrm1 = script_ref_create(Voltergeist_alrm1);
        
        return self;
}

#define Voltergeist_step
	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;
	if("on_alrm2" in self and alarm2_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }

		// Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
		// Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;
	
		// Stay with Me:
	if possessing = true { x = host.x; y = host.y }
		// DIE:
	if possessions > possesionmax { Voltergeist_destroyed() }
	
	instance_create(x,y,Curse)
	
#define Voltergeist_alrm1
	alarm1 = 10 + irandom(5);

var nearest_possessable = call(scr.instance_nearest_array, x, y, instances_matching(prop, "ei_possessable", true) );


if array_length(instances_matching(prop, "ei_possessable", true)) > 0 {
	
	
		// Go to nearest possessable prop if not possessing anything
	if possessing = false and (chance(1, 2)) {
		direction = point_direction(x,y,nearest_possessable.x,nearest_possessable.y)
		enemy_walk(direction, alarm1);
		
		}
	}
	// die if no possessable objects exist and not possessing something
if possessing = false and array_length(instances_matching(prop, "ei_possessable", true)) <= 0 { wait(random(10)) Voltergeist_destroyed()}

#define Voltergeist_death
pickup_drop(7, 0, 1);
repeat(random_range(4,7)) { instance_create(x+random_range(-10,10),y+random_range(-10,10),BlueFlame) }
call(scr.sound_play_at, x, y, sndIDPDNadeExplo,1 + random(0.2),0.4, 128, 1);  // Sounds
call(scr.sound_play_at, x, y, sndExplosionS,1 + random(0.4),0.8, 128, 1);

#define Voltergeist_destroyed
corpse_drop(self, direction, 0);
Voltergeist_death()
instance_destroy()


	//Cremator:
#define Cremator_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Cremator"
    	
        //Visuals:
        spr_idle = global.sprCrematorIdle;
		spr_walk = global.sprCrematorIdle;
		spr_hurt = sprBanditHurt; 
		spr_dead = sprBanditDead;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "CREMATOR"]
        spr_shadow      = global.shdCremator;
        spr_shadow_y    = 2;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndTurretHurt;
        snd_dead = sndTurretDead;
        
        //Vars:
        mask_index    = mskBigMaggot;
        direction     = random(360);
        maxhealth     = 20;
       	my_health     = maxhealth;
        raddrop       = 7;
        maxspeed      = 3.5;
        walkspeed     = maxspeed;
        gunangle      = 180;
        canmelee      = 0;
        meleedamage   = 0;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        
        //Alarms:
        alarm1 = 40 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(Cremator_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = StandardDrops;
        on_alrm1 = script_ref_create(Cremator_alrm1);
        
        return self;
}

#define Cremator_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
	 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;

#define Cremator_alrm1
	alarm1 = 40 + irandom(30);

	if(enemy_target(x, y) and target_visible) {
		enemy_look(target_direction);
		
			// Move Towards target when too far away
		if(target_distance > 128){
			alarm1 = 30 + irandom(15);
			enemy_walk(target_direction + orandom(30), alarm1 - 10);
		}
			 // If in range:
		if(target_distance < 128){
			 // Attack:
			 // Not too close!
			if(chance(3, 4) and (target_distance > 32)){
				alarm1 = 45 + irandom(20);
				repeat(10) {
					with instance_create(x,y,TrapFire){
						hitid = other.hitid;
						speed = 3 + random(3);
						team = other.team
						direction = other.gunangle+random_range(-6,6);
						creator = other;
						image_angle = direction;
						
					}
				}
				
				sound_play_pitch(sndFireShotgun, 1.1 + random(0.3));
				motion_add(gunangle, 2);
			}
			
					 // Move Away From Target:
			else{
				alarm1 = 30 + irandom(15);
				enemy_walk(gunangle + 180 + orandom(30), alarm1 - 10);
			}
		}
	}
	
	 // Wander Around Town:
	else{
		enemy_walk(random(360), 30);
		enemy_look(direction);
	}
	

//#region DEEPLABS ENEMIES

	//Raven Amalgam:
#define RavenAmalgam_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Raven Amalgam"
    	
        //Visuals:
        spr_idle = global.sprRavenAmalgamIdle;
		spr_walk = global.sprRavenAmalgamWalk;
		spr_hurt = sprRhinoFreakHurt; 
		spr_dead = sprRhinoFreakDead;
		spr_chrg = global.sprRavenAmalgamCharge;
		spr_wait = sprRhinoFreakHurt;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "RAVEN AMALGAM"]
        spr_shadow      = shd32;
        spr_shadow_y    = 4;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndRavenHit;
        snd_dead = sndRavenDie;
        snd_mele = sndRavenScreech;
        
        //Vars:
        mask_index    = mskRhinoFreak;
        direction     = random(360);
        size		  = 2;
        maxhealth     = 25;
       	my_health     = maxhealth;
        raddrop       = 7;
        maxspeed      = 3;
        walkspeed     = maxspeed;
        chargespeed   = 3.5;
        canmelee      = 1;
        normaldamage  = 2;
        chargedamage  = 5;
        meleedamage   = normaldamage;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        charging	  = 0;
        chargewait    = 0;
        
        //Alarms:
        alarm1 = 40 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(RavenAmalgam_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = RavenAmalgam_hurt;
        on_death = RavenAmalgam_death;
        on_alrm1 = script_ref_create(RavenAmalgam_alrm1);
        
        return self;
}

#define RavenAmalgam_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(sprite_index != spr_chrg || sprite_index != spr_wait || anim_end){
		sprite_index = enemy_sprite;
	}

		// Pause Before Charge: //

	if(chargewait > 0){
		// Set Sprite:
	if(sprite_index != spr_hurt){
	sprite_index = spr_wait;
	}
	
	if chargewait > 0 { chargewait -= current_time_scale }
	
	}
	
		// Charging: //
		
	if(charging > 0){
		// Set Sprite:
	if(sprite_index != spr_hurt){
	sprite_index = spr_chrg;
	}

		// Count Down:
	if charging > 0 { charging -= current_time_scale; }
	
		// I Am Speed:
	motion_add(direction, 3);
	enemy_look(direction);
	instance_create(x,y,Dust)
	if random(4) < 1 { with instance_create(x,y,Feather) { sprite_index = sprRavenFeather; direction = -other.direction; speed = irandom(3); } }
		
		// Hit Walls: 
	if(place_meeting(x + hspeed_raw, y + vspeed_raw, Wall)){
		sound_play_pitchvol(sndMeleeWall,random_range(0.6,0.8),1)
		with instance_create(x,y,PortalClear){ image_xscale = 0.6; image_yscale = image_xscale; }
	   // Particles:
		with instance_create(x,y,ImpactWrists){ depth = -3; }
		repeat(10) { with instance_create(x,y,Dust){ direction = random(360); speed = 4 } }
		
		charging = 0
	}
		
	}
	
	if (charging <= 0){ maxspeed = walkspeed; meleedamage = normaldamage; }
	
		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;
	
	
#define RavenAmalgam_alrm1
	alarm1 = 30 + irandom(5);
	
	if(enemy_target(x, y) and target_visible) and chargewait <= 0 and charging <= 0 {
			direction = point_direction(x,y,target.x,target.y)
		enemy_walk(direction, alarm1);
	}
	
				if !instance_exists(target){ exit; }
	
		// Charge:
	if(chance(1, 3) and target_visible and charging <= 0 and chargewait <= 0) and target_distance < 224{
		
			chargewait = 15;
			walk = 0;
			speed = 0;
			alarm1 = 60 + irandom(5);
			wait(chargewait){
			if !instance_exists(self){ exit; }
			
		if(enemy_target(x, y)){
			direction   = target_direction;
			gunangle    = target_direction;
			charge_dir  = target_direction;
			charging    = 15 + irandom(10);
			maxspeed    = chargespeed; 
			meleedamage = chargedamage;
			call(scr.sound_play_at, x, y, sndRavenScreech,0.55 + random(0.1),0.7, 228, 1);
			//sound_play_pitchvol(sndRavenScreech,0.6,0.7)

			}
		}
	}
	
	//else {
		if(chance(1, 3)) and chargewait <= 0 and charging <= 0{
		direction = random(360);
		enemy_walk(direction, alarm1);
		}
	//}
	
#define RavenAmalgam_hurt(_damage, _force, _direction)
	my_health -= _damage;           // Damage
	nexthurt = current_frame + 6;   // I-Frames
	motion_add(_direction, _force); // Knockback
	sound_play_pitchvol(sndRavenHit,random_range(0.5,0.7),0.9)  // Sound
	
	 // Hurt Sprite:
	sprite_index = spr_hurt;
	image_index  = 0;

#define RavenAmalgam_death
	if(snd_dead == sndRavenDie){
		sound_play_hit_ext(snd_dead, 0.55 + random(0.2), 1);
	}
	sound_play_pitchvol(sndRavenDie,random_range(0.5,0.7),0.9)  // Sound
	
	repeat(random_range(6,9)) { with instance_create(x,y,Feather){ sprite_index = sprRavenFeather; } }
	
//#region PALACE ENEMIES

	//Splitter Guardian:
#define GupGuardian_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Splitter Guardian"
    	
        //Visuals:
        spr_idle = global.sprGupGuardianIdle;
		spr_walk = global.sprGupGuardianWalk;
		spr_hurt = global.sprGupGuardianHurt; 
		spr_dead = global.sprGupGuardianDead;
		sprite_index    = spr_walk;
		image_speed     = 0.4;
		depth           = -2;
		image_index 	= random(7);
		hitid           = [spr_idle, "SPLITTER GUARDIAN"]
        spr_shadow      = global.shdGupGuardian;	
        spr_shadow_y    = 19;
        nts_color_blood = [make_color_rgb(190, 253, 8)]
        
        //Sounds:
        snd_hurt = sndDogGuardianHurt;
        //snd_dead = sndDogGuardianDead;
        snd_mele = sndDogGuardianMelee;
        
        //Vars:
        mask_index    = global.mskGupGuardian;
        direction     = random(360);
        maxhealth     = 100;
       	my_health     = maxhealth;
        raddrop       = 12;
        maxspeed      = 1.3;
        walkspeed     = maxspeed;
        canmelee      = 1;
        meleedamage   = 6;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        gupwalk		  = 0;
        jumpframego   = 2;
        jumpframestop = 7;
        size		  = 3;
        
        //Alarms:
        alarm1 = 20 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(GupGuardian_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = GupGuardian_death;
        on_alrm1 = script_ref_create(GupGuardian_alrm1);
        
        return self;
}
#define GupGuardian_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
	else sprite_index = enemy_sprite;
	
		// Hop to u:
	if(instance_exists(target) and target_visible){
		if sprite_index != spr_hurt { sprite_index = spr_walk }
			if image_index > jumpframego and image_index < jumpframestop {
		motion_add(direction - (angle_difference(direction, point_direction(x, y, target.x, target.y)) * 0.3), walkspeed);
		enemy_face(direction);
			}
	}
	
		// Hop to anyone
	if(gupwalk > 0){
		gupwalk -= current_time_scale;
			if image_index > jumpframego and image_index < jumpframestop {
		motion_add(direction, walkspeed / 2);
		enemy_face(direction);
			// Make sure you follow through
		if gupwalk = 1 { gupwalk = 2 }
			}
	}

		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;

#define GupGuardian_alrm1
	alarm1 = 30 + irandom(5);
	
		if(chance(1, 4)) and !target_visible or (chance(1, 4)) and !instance_exists(target){
		direction = random(360);
		gupwalk += alarm1
		}
	
	
#define GupGuardian_death
instance_create(x,y,PortalClear)
pickup_drop(7, 5, 1);
sound_play_pitch(sndExploGuardianDeadCharge,random_range(0.7,0.8))
repeat(4){ GeepGuardian_create(x,y) }

#define GeepGuardian_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Splitter Guardian"
    	
        //Visuals:
        spr_idle = global.sprGeepGuardianIdle;
		spr_walk = global.sprGeepGuardianWalk;
		spr_hurt = global.sprGeepGuardianHurt; 
		spr_dead = global.sprGeepGuardianDead;
		sprite_index    = spr_walk;
		image_speed     = 0.4;
		depth           = -2;
		image_index 	= random(7);
		depth           = -2;
		hitid           = [spr_idle, "SPLITTER GUARDIAN"]
        spr_shadow      = shd48;	
        spr_shadow_y    = 8;
        nts_color_blood = [make_color_rgb(190, 253, 8)]
        
        //Sounds:
        snd_hurt = sndExploGuardianHurt;
        //snd_dead = sndExploGuardianDead;
        snd_mele = sndDogGuardianMelee;
        
        //Vars:
        mask_index    = mskExploGuardian;
        direction     = random(360);
        maxhealth     = 25;
       	my_health     = maxhealth;
        raddrop       = 4;
        maxspeed      = 1.7;
        walkspeed     = maxspeed;
        canmelee      = 1;
        meleedamage   = 4;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        gupwalk		  = 0;
        jumpframego   = 2;
        jumpframestop = 7;
        size		  = 2;
        
        //Alarms:
        alarm1 = 20 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(GupGuardian_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = GeepGuardian_death;
        on_alrm1 = script_ref_create(GeepGuardian_alrm1);
        
        return self;
}

#define GeepGuardian_alrm1
	alarm1 = 20 + irandom(5);
	
		if(chance(1, 3)) and !target_visible or (chance(1, 3)) and !instance_exists(target) {
		direction = random(360);
		gupwalk += alarm1
		}
		
#define GeepGuardian_death
with instance_create(x,y,PortalClear){ image_xscale = 0.8; image_yscale = image_xscale; }
pickup_drop(7, 2, 1);
sound_play_pitch(sndExploGuardianDeadCharge,random_range(1,1.1))
repeat(4){ GipGuardian_create(x,y) }

#define GipGuardian_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Splitter Guardian"
    	
        //Visuals:
        spr_idle = global.sprGipGuardianIdle;
		spr_walk = global.sprGipGuardianWalk;
		spr_hurt = global.sprGipGuardianHurt; 
		spr_dead = global.sprGipGuardianDead;
		sprite_index    = spr_walk;
		image_speed     = 0.4;
		depth           = -2;
		image_index 	= random(7);
		depth           = -2;
		hitid           = [spr_idle, "SPLITTER GUARDIAN"]
        spr_shadow      = shd24;	
        spr_shadow_y    = 0.5;
        nts_color_blood = [make_color_rgb(190, 253, 8)]
        
        //Sounds:
        snd_hurt = sndGuardianHurt;
        snd_dead = sndGuardianDead;
        snd_mele = sndDogGuardianMelee;
        
        //Vars:
        mask_index    = mskBandit;
        direction     = random(360);
        maxhealth     = 6;
       	my_health     = maxhealth;
        raddrop       = 2;
        maxspeed      = 2;
        walkspeed     = maxspeed;
        canmelee      = 1;
        meleedamage   = 2;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        gupwalk		  = 0;
        jumpframego   = 2;
        jumpframestop = 7;
        size		  = 1;
        
        //Alarms:
        alarm1 = 20 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(GupGuardian_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = GipGuardian_death;
        on_alrm1 = script_ref_create(GipGuardian_alrm1);
        
        return self;
}

#define GipGuardian_alrm1
	alarm1 = 10 + irandom(5);
	
		if(chance(1, 3)) and !target_visible or (chance(1, 3)) and !instance_exists(target){
		direction = random(360);
		gupwalk += alarm1
		}
		
#define GipGuardian_death
speed = 3
pickup_drop(50, 0, 1);

//#region IDPD ENEMIES

	//Enforcer (Bubbles Unit):
#define PopoBubbles_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Enforcer"
    	
        //Visuals:
        spr_idle = global.sprPopoBubblesIdle;
		spr_walk = global.sprPopoBubblesWalk;
		spr_hurt = global.sprEngineerHurt; 
		spr_dead = global.sprEngineerDead;
		spr_weap = global.sprPopoBubblesBaton;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "ENFORCER"]
        spr_shadow      = shd24;	
        spr_shadow_y    = -1;
        nts_color_blood = [c_red, make_color_rgb(134, 44, 35)]
        
		// Sounds:
		male = irandom(1);
		var m = (male ? "M" : "F");
		snd_hurt = sndEliteGruntHurt;
		snd_dead = sndEliteGruntDead;
		call(scr.sound_play_at, x, y, sndEliteGruntEnter,0.8 + random(0.1),0.8, 128, 1);
        
        //Vars:
        mask_index    = mskBandit;
        direction     = random(360);
        maxhealth     = 20;
       	my_health     = maxhealth;
        raddrop       = 0;
        maxspeed      = 3;
        walkspeed     = maxspeed;
        canmelee      = 0;
        meleedamage   = 0;
        team          = 3;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        gunangle      = 180;
		wepangle	  = 140 * choose(-1, 1);
    	freeze		  = 0;
    	activebubbles = 0;
    	bubblemax     = 5;
        
        //Alarms:
        alarm1 = 30;
        alarm2 = -1;

        //Scripts:
        on_step  = script_ref_create(PopoBubbles_step);
        on_draw  = MeleeEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = PopoBubbles_death;
        on_alrm1 = script_ref_create(PopoBubbles_alrm1);
        on_alrm2 = script_ref_create(PopoBubbles_alrm2);
        
        return self;
}

#define PopoBubbles_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;
	if("on_alrm2" in self and alarm2_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
	else sprite_index = enemy_sprite;
	
	 // Sense Danger:
	if(instance_exists(Player)){
		with(Player){
			if(speed > 0 || my_health < maxhealth){
				other.freeze += current_time_scale;
			}
			if(can_shoot == false){
				other.freeze += 3 * current_time_scale;
			}
		}
	}
    
		//Use Your Eyes:
	right = (gunangle + 270) mod 360 > 180 ? 1 : -1;
	
#define PopoBubbles_alrm1
	alarm1 = 30;
	
		if(enemy_target(x, y) && target_visible){
			alarm1 = random_range(10, 20);
			
			enemy_look(target_direction);
			
			if(target_distance < 60){
				 // Begin Attack:
				if(chance(2, 3)){
					alarm2 = 1;
				}
				
				 // Strafe:
				else enemy_walk(
					gunangle + (random_range(30, 90) * choose(-1, 1)),
					random_range(10, 20)
				);
			}
			
			 // Move Closer:
			else enemy_walk(
				gunangle + orandom(30),
				random_range(10, 20)
			);
		}
		
		 // Wander:
		else if(chance(1, 3)){
			alarm1 = random_range(20, 30);
			enemy_walk(random(360), random_range(20, 40));
			enemy_look(direction);
		}

#define PopoBubbles_alrm2
	alarm1 = 40 + random(20);
	trace("1")
	
	// Melee Attack:
	if (enemy_target(x, y) and target_visible) and target_distance < 60 and (chance(2, 3)) {
		alarm1 = 40 + random(20);
	
			//Warning:
	instance_create(x,y,AssassinNotice)
		wait(10);
	if !instance_exists(self){ exit;}
	gunangle = target_direction;
			
			//Slash:
	with instance_create((x+lengthdir_x(1, gunangle)),(y+lengthdir_y(1, gunangle)),EnemySlash){
		sound_play_pitch(sndWrench, 1 + random(0.3));
		hitid		= other.hitid;
		damage	    = 4;
		speed	    = 1;
		team        = other.team;
		direction   = other.gunangle+random_range(-15,15);
		creator     = other;
		image_angle = direction;
		}
	}
	
	else{
	
	// Bubble Attack:
	if (enemy_target(x, y) and target_visible) and (chance(2, 3)) and activebubbles < bubblemax {
		alarm1 = 40 + random(20);
		
		repeat(random_range(1,3)){
	with(instance_create(x + lengthdir_x(5,gunangle),y + lengthdir_y(5,gunangle),CustomSlash)){
		
		trace("bubble!")
					
		direction			 = other.gunangle+random_range(-15,15);
		sprite_index		 = global.sprPopoBubbleProjectile;
		mask_index  		 = mskEnemyBullet1;
		ei_bloomamount		 = 1.2;
		ei_bloomtransparency = 0.1;
		image_angle 	     = random(360);
		hitid				 = other.hitid;
		team        		 = other.team;
		creator				 = other;
		speed                = 3 + random_range(1,2);
		friction			 = 0.2;
		ignore_muts 		 = true;
		nulls				 = 0;
		timer				 = 200;
					
		on_projectile		 = popobubble_nullify;
		on_anim     		 = nothing;
		on_step 			 = popobubble_step;
				//	on_wall       = bubbleprojectile_wall
				 //   on_hit        = bubbleprojectile_hit
				  //  on_destroy    = bubbleprojectile_destroy
				    
				}	
			}				
		}
	}
				
			
#define PopoBubbles_death
     // Pickups:
    pickup_drop(20, 0);

	 // Activate Popo:
	with(instances_matching_ne(enemy, "freeze", null)){
		if(is_real(freeze)){
			freeze += 100;
		}
	}
	with(WantVan){
		canspawn = true;
	}

	//Exploder:
#define PopoExploder_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Exploder"
    	
        //Visuals:
        spr_idle = global.sprPopoExploder;
		spr_walk = global.sprPopoExploder;
		spr_hurt = global.sprPopoExploderHurt; 
		spr_dead = global.sprPopoExploderDead;
		spr_chrg = global.sprPopoExploderBlink;
	//	spr_flme = global.sprPopoExploderFlame;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "EXPLODER"]
        spr_shadow      = shd24;	
        spr_shadow_y    = 6;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndHydrantBreak;
        snd_dead = sndPlantPotBreak;
        
        //Vars:
        mask_index    = mskFreak;
        direction     = random(360);
        maxhealth     = 15;
       	my_health     = maxhealth;
        raddrop       = 2;
        normalspeed   = 2.5; //maxspeed when no target
        targetspeed   = 5;    //maxspeed when target
        maxspeed      = 2;
        walkspeed     = maxspeed;
        canmelee      = 0;
        team          = 3; 
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        explostate    = false;
        explotimer    = 25;
        
        //Alarms:
        alarm1 = 20 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(PopoExploder_step);
        on_draw  = PopoExploder_draw;
        on_hurt  = Enemy_hurt;
        on_death = PopoExploder_death;
        on_alrm1 = script_ref_create(PopoExploder_alrm1);
        
        return self;
}
#define PopoExploder_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if explostate = true {
		sprite_index = spr_chrg
	}
	if(anim_end){
		 //Checks if not firing or rolling
			if explostate = false {
		sprite_index = (speed > 0) ? spr_walk : spr_idle;
		}
	}
	
	else if explostate = false { sprite_index = enemy_sprite; }
	
		// Change Movement Speeds:
	if instance_exists(target){
	if  target_visible { maxspeed = targetspeed }
	if !target_visible { maxspeed = normalspeed }
	}
	
		// Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;
	
		// Change Da Y
	var _y = y + sin(current_frame * 0.06)*4.5
	
		// Paricles:
	if (speed > 1) and current_frame_active {
	with instance_create(x,_y,PlasmaTrail){ sprite_index = sprPopoPlasmaTrail; }
	}
	//with instance_create(x + random_range(-5,5),_y + random_range(-5,5),PlasmaTrail){ sprite_index = sprIDPDPortalCharge; }
	
	
		// When Close start the bomnb:
	if instance_exists(target){
	if target_distance < 40 { explostate = true }
	}
	
		// WHEN GONNA BLOW:
	if explostate = true {
		
		if explotimer = 24 { instance_create(x,y,AssassinNotice) image_index = 0 }
		
		call(scr.sound_play_at, x, y, sndIDPDNadeAlmost,0.4 + random(0.1),0.8, 128, 1);
		
		walk = 0
		// The Final Countdown:
		explotimer -= current_time_scale 
		
		// Particles:
		if current_frame_active{
    repeat(2) with(instance_create(x + orandom(48), y + orandom(48), IDPDPortalCharge)){
        motion_add(point_direction(x, y, other.x, other.y), 3 + random(1));
        alarm0 = (point_distance(x, y, other.x, other.y) / speed) + 1;
            }
		}
	}
	
	if explotimer < 0 { PopoExploder_explo() }

#define PopoExploder_alrm1
	alarm1 = 10 + irandom(5);
				
		// Go to him:
	if(enemy_target(x, y) and target_visible) and explostate = false{
			direction = point_direction(x,y,target.x,target.y)
		enemy_walk(direction, alarm1);
	}
	
	else {
		if(chance(1, 2)) and explostate = false {
		direction = random(360);
		enemy_walk(direction, alarm1);
		}
	}


#define PopoExploder_explo
	
    with instance_create(x+lengthdir_x(25, direction),y,PopoExplosion){ team = other.team; hitid = other.hitid;}
    with instance_create(x+lengthdir_x(-25, direction),y,PopoExplosion){ team = other.team; hitid = other.hitid;} 
    with instance_create(x,y+lengthdir_x(25, direction),PopoExplosion){ team = other.team; hitid = other.hitid;}
    with instance_create(x,y+lengthdir_x(-25, direction),PopoExplosion){ team = other.team; hitid = other.hitid;} 
    repeat(random_range(7,15)) { instance_create(x+random_range(-40,40),y+random_range(-40,40),BlueFlame) }

//	repeat(2) { with instance_create(x,y,PopoExplosion){ sprite_index = sprRogueExplosion; mask_index = mskExplosion;  team = other.team; hitid = other.hitid;} }
	
		// DIE:	
	PopoExploder_death()
	corpse_drop(self, direction, max(7, speed));
	instance_destroy()
#define PopoExploder_death
pickup_drop(7, 0, 1);
repeat(random_range(4,7)) { instance_create(x+random_range(-10,10),y+random_range(-10,10),BlueFlame) }
call(scr.sound_play_at, x, y, sndIDPDNadeExplo,1 + random(0.2),0.4, 128, 1);  // Sounds
call(scr.sound_play_at, x, y, sndExplosionS,1 + random(0.4),0.8, 128, 1);
//sound_play_pitchvol(sndIDPDNadeExplo,1 + random(0.2),0.4)
//sound_play_pitchvol(sndExplosionS,1 + random(0.4),0.8)
with instance_create(x,y,PopoExplosion){ sprite_index = sprRogueExplosion; mask_index = mskExplosion;  team = other.team; hitid = other.hitid; }

#define PopoExploder_draw
var _y = y + sin(current_frame * 0.06)*4.5
//{
//	draw_sprite_ext(spr_flme, current_frame * .4, x - 4, _y, 1 * right, 1, 0, c_white, image_alpha);
//	draw_set_blend_mode(bm_add);
//}
draw_set_blend_mode(bm_normal);
draw_sprite_ext(sprite_index,image_index,x,_y,image_xscale * right, image_yscale, image_angle, image_blend, image_alpha);
//#region DEVZONE ENEMIES
	//Roomba:
#define Roomba_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Roomba"
    	
        //Visuals:
        spr_idle = global.sprRoomba;
		spr_walk = global.sprRoomba;
		spr_hurt = global.sprRoombaHurt; 
		spr_dead = global.sprRoombaDead;
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		hitid           = [spr_idle, "ROOMBA"]
        spr_shadow      = shd24;	
        spr_shadow_y    = -6;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndHydrantBreak;
        snd_dead = sndPlantPotBreak;
        
        //Vars:
        mask_index    = mskFreak;
        direction     = random(360);
        maxhealth     = 8;
       	my_health     = maxhealth;
        raddrop       = 0;
        maxspeed      = 2;
        walkspeed     = maxspeed;
        canmelee      = 0;
        meleedamage   = 0;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        
        //Alarms:
        alarm1 = 20 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(Roomba_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = Swarmbot_death;
        on_alrm1 = script_ref_create(Roomba_alrm1);
        
        return self;

}

#define Roomba_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
	 // Animate:
	if(anim_end){ sprite_index = (speed > 0) ? spr_walk : spr_idle; }
	
	// Dust:
	if speed > 0.5 and (random(4) < 1) {
		with instance_create(x,y,Dust){ 
			sprite_index = global.sprWhiteSmoke
			image_xscale = 0.2
			image_yscale = image_xscale
		    } 
	}
	
		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;

#define Roomba_alrm1

		alarm1 = 20 + irandom(20);

		if(chance(1, 2)) {
		direction = random(360);
		enemy_walk(direction, 50);
	}

//#endregion
//#region BOSSES
	//Mechnomancer:
#define Mechnomancer_create(_x, _y)
with instance_create(_x, _y, CustomEnemy){
    
    	name = "Mechnomancer"
    	
        //Visuals:
        spr_idle = sprSnowTankIdle;
		spr_walk = sprSnowTankWalk;
		spr_hurt = sprSnowTankHurt; 
		spr_dead = sprSnowTankDead;
		spr_chrg = sprGoldTankWalk; // Sawblade Charge
		spr_wait = sprGoldTankHurt; // Sawblade Charge Prepare
		sprite_index    = spr_idle;
		image_speed     = 0.4;
		depth           = -2;
		hitid           = [spr_idle, "MECHNOMANCER"]
        spr_shadow      = shd24;	
        spr_shadow_y    = 0.5;
        nts_color_blood = [make_color_rgb(96, 59, 52), c_black]
        
        //Sounds:
        snd_hurt = sndHydrantBreak;
        snd_dead = sndPlantPotBreak;
        
        //Vars:
        mask_index    = mskLast;
        direction     = random(360);
        maxhealth     = 8;
       	my_health     = maxhealth;
        raddrop       = 2;
        normalspeed   = 2.5; //maxspeed when no target
        sawspeed	  = 4;	 //maxspeed when target
        maxspeed      = 2;
        walkspeed     = maxspeed;
        canmelee      = 1;
        meleedamage   = 2;
        team          = 1;
        targetvisible = 0;
        target        = 0;
        walk          = 0;
        sawcharging	  = 0;
        sawchargewait = 0;
        sawdamage	  = 5;
        charge_dir	  = 0;
        size		  = 6;
        
        //Alarms:
        alarm1 = 20 + irandom(30);

        //Scripts:
        on_step  = script_ref_create(Mechnomancer_step);
        on_draw  = BasicEnemy_draw;
        on_hurt  = Enemy_hurt;
        on_death = Swarmbot_death;
        on_alrm1 = script_ref_create(Mechnomancer_alrm1);
        
        return self;
}

#define Mechnomancer_step

	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;

		// Movement:
	if(walk > 0){ walk -= current_time_scale;   speed += walkspeed * current_time_scale;   gunangle = direction }
	
		//Speed Cap:
	if(speed > maxspeed){ speed = maxspeed; }
	
		 // Animate:
	if(sprite_index != spr_chrg || sprite_index != spr_wait || anim_end){
		sprite_index = enemy_sprite;
	}

		// Saw Charge Prepare: //

	if(sawchargewait > 0){
		// Set Sprite:
	if(sprite_index != spr_hurt){
	sprite_index = spr_wait;
	}
	
	if sawchargewait > 0 { sawchargewait -= current_time_scale }
	
	}
	
		// Sawcharging: // 
		
	if(sawcharging > 0){
		// Set Sprite:
	if(sprite_index != spr_hurt){
	sprite_index = spr_chrg;
	}
	
	direction = angle_lerp_ct(direction, charge_dir + (sin(sawcharging / 5) * 20), 1/3);
	
		// Set and Unset Speed and Melee Damage:
	if sawcharging > 0 { maxspeed = sawspeed; canmelee = true; }

		// Count Down:
	if sawcharging > 0 { sawcharging -= current_time_scale; }
	
		// I Am Speed:
	motion_add(direction, 3);
	enemy_look(direction);
	instance_create(x,y,Dust)
		
		// Hit Walls: 
	if(place_meeting(x + hspeed_raw, y + vspeed_raw, Wall)){
		sound_play_pitchvol(sndMeleeWall,random_range(0.6,0.8),1)
	}
		
	}
	
	if sawcharging = 0 { maxspeed = normalspeed; canmelee = false; }
	
		//Use Your Eyes:
	right = (direction + 270) mod 360 > 180 ? 1 : -1;

#define Mechnomancer_alrm1
	alarm1 = 10 + irandom(5);
	
	if(enemy_target(x, y) and target_visible) and target_distance > 70 {
			direction = point_direction(x,y,target.x,target.y)
		enemy_walk(direction, alarm1);
	}
	
		// Saw Charge:
	if(chance(1, 5) and sawcharging = 0 and sawchargewait = 0){
		
			sawchargewait = 30;
			walk = 0;
			speed = 0;
			wait(30){
			if !instance_exists(self){ exit; }
			
		if(enemy_target(x, y)){
			trace("charge")
			direction   = target_direction;
			gunangle    = target_direction;
			charge_dir  = target_direction;
			sawcharging = 35 + irandom(10);
			sound_play_pitchvol(sndBigDogTaunt,1.3,0.7)
			sound_play_pitchvol(sndTechnomancerAppear,1,1.5)
			
		// Wallbreaking Aura:
	with instance_create((x+lengthdir_x(0, direction)),(y+lengthdir_y(0, direction)),CustomProjectile){
    	creator = other;
	    timer = other.sawcharging;
    	sprite_index = sprLastIdle;
	    mask_index   = mskScrapBoss;
	    on_hit  = nothing;
        on_wall = MechnomancerWallbreak_wall;
        on_step = MechnomancerWallbreak_step;
	}

			}
		}
	}
	
	else {
		if(chance(1, 5)) and sawchargewait = 0 {
		direction = random(360);
		enemy_walk(direction, alarm1);
		}
	}

//#endregion
//#region ENEMY PROJECTILES

//Engineer Swarmbot
#define EngineerProjectile_step
if current_frame_active { with instance_create(x,y,Smoke){ sprite_index = global.sprWhiteSmoke; image_xscale = 0.5; image_yscale = image_xscale; growspeed = -0.08; } }

	speed = 10
		if place_meeting(x,y,Wall){
		x = xprevious;
		y = yprevious;
	}
	if place_meeting(x + hspeed, y + vspeed, Wall){
		x = xprevious;
		y = yprevious;
		instance_destroy();
		
	}
#define EngineerProjectile_destroy
with Swarmbot_create(xprevious,yprevious) { raddrop = 0 }

//Labs MicroMissile
#define LabsRocket_create(xx,yy)

	 // You gotta put      image_angle  = direction;   with the creation code idk why
  with instance_create(xx, yy, CustomProjectile)
    {
      // Visuals:
      sprite_index = global.sprLabsRocket;
      mask_index   = global.mskLabsRocket;
      image_angle  = direction;
	  
      // Vars:
      speed   = 12;
      typ     = 1;
      damage  = 0;
      creator = other;
      team    = other.team;
      hitid   = [sprite_index, "MICROMISSILE"];

      on_draw	 = LabsRocket_draw;
      on_step	 = LabsRocket_step;
      on_destroy = LabsRocket_destroy;

	return self;

    }
    
#define LabsRocket_destroy
sound_play_pitchvol(sndExplosion, 0.5 + random_range(0.8,1.3),0.8)
sound_play_pitchvol(sndPlasma, 0.5 + random_range(0.8,1.3),1.2)
with LabsRocketExplosion_create(x,y){
    team = other.team;
    creator = other.creator;
    hitid = other.hitid;
  }


#define LabsRocket_step
if current_frame_active{
with instance_create(x+random_range(-4,4),y+random_range(-4,4),PlasmaTrail){ sprite_index = global.sprLabsRocketTrail; direction = other.direction; speed = 2; image_xscale = 0.7; image_yscale = image_xscale; }
//with instance_create(x+random_range(-1,1),y+random_range(-1,1),Smoke){ image_xscale = 0.5; image_yscale = image_xscale; growspeed = -0.08;  }
}
#define LabsRocket_draw
{
	draw_sprite_ext(global.sprLabsRocketFlame, current_frame * .4, x, y, 1, 1.2, image_angle, c_white, image_alpha);
	draw_set_blend_mode(bm_add);
	draw_sprite_ext(global.sprLabsRocketFlame, current_frame * .4, x, y, 1.8 * image_xscale, 1.8 * image_yscale, image_angle, c_white, 0.2);
}
draw_set_blend_mode(bm_normal);
draw_self();

#define LabsRocketExplosion_create(xx,yy)

  with instance_create(xx, yy, CustomProjectile)
    {
      name = "ei_labsrocketexplosion"
      // Visuals:
      sprite_index = global.sprLabsRocketExplosion;
      mask_index   = mskSmallExplosion;
      image_speed  = 0.4;
      image_angle  = random(360);
	  ei_bloomamount       = 2;
	  ei_bloomtransparency = 0.1;
	  
      // Vars:
      damage  = 2;
      typ     = 1;
      creator = other;
      team    = other.team;
      hitid   = other.hitid;
      hitlist = [];

	  
	  on_wall    = nothing;
	  on_hit     = LabsRocketExplosion_hit;
      on_step	 = LabsRocketExplosion_step;


	return self;

    }
    
#define LabsRocketExplosion_hit
    if array_find_index(hitlist,other) == -1{
        projectile_hit(other, damage, damage, direction)
        array_push(hitlist,other)
    }
    
    
#define LabsRocketExplosion_step
if image_index + image_speed >= image_number{ instance_destroy(); }

#define popobubble_nullify
if(instance_exists(self)){
		if (other.typ > 0) {
			 with (other){
			  	instance_destroy()
			  } } }
#define popobubble_step
timer =- current_time_scale;

if (random(25) < current_time_scale){
with instance_create(x+random_range(-1,1),y+random_range(-1,1),PlasmaTrail){ sprite_index = sprPopoPlasmaTrail;}
}
if nulls > 5 or timer < 0 { instance_destroy(); }

#define MechnomancerWallbreak_wall
with(other){ instance_create(x, y, FloorExplo); instance_destroy();}
#define MechnomancerWallbreak_step
if instance_exists(creator){
		xprevious = creator.x;
		yprevious = creator.y;
		x = creator.x;
		y = creator.y;
}
timer -= current_time_scale;
if timer < 0 { instance_destroy(); }

//#endregion
//#region GENERIC FUNCTIONS

#macro  target_visible                                                                          !collision_line(x, y, target.x, target.y, Wall, false, false)
#macro  target_direction                                                                        point_direction(x, y, target.x, target.y)
#macro  target_distance                                                                         point_distance(x, y, target.x, target.y)
#macro  anim_end																				((image_index + image_speed_raw) >= image_number || (image_index + image_speed_raw) < 0)
#macro  enemy_sprite                                                                            (sprite_index != spr_hurt || anim_end) ? ((speed == 0) ? spr_idle : spr_walk) : sprite_index
#macro  alarm0_run                                                                              alarm0 && !--alarm0 && !--alarm0 && (script_ref_call(on_alrm0) || !instance_exists(self))
#macro  alarm1_run                                                                              alarm1 && !--alarm1 && !--alarm1 && (script_ref_call(on_alrm1) || !instance_exists(self))
#macro  alarm2_run                                                                              alarm2 && !--alarm2 && !--alarm2 && (script_ref_call(on_alrm2) || !instance_exists(self))
#macro  alarm3_run                                                                              alarm3 && !--alarm3 && !--alarm3 && (script_ref_call(on_alrm3) || !instance_exists(self))
#macro  alarm4_run                                                                              alarm4 && !--alarm4 && !--alarm4 && (script_ref_call(on_alrm4) || !instance_exists(self))
#macro  alarm5_run                                                                              alarm5 && !--alarm5 && !--alarm5 && (script_ref_call(on_alrm5) || !instance_exists(self))
#macro  alarm6_run                                                                              alarm6 && !--alarm6 && !--alarm6 && (script_ref_call(on_alrm6) || !instance_exists(self))
#macro  alarm7_run                                                                              alarm7 && !--alarm7 && !--alarm7 && (script_ref_call(on_alrm7) || !instance_exists(self))
#macro  alarm8_run                                                                              alarm8 && !--alarm8 && !--alarm8 && (script_ref_call(on_alrm8) || !instance_exists(self))
#macro  alarm9_run                                                                              alarm9 && !--alarm9 && !--alarm9 && (script_ref_call(on_alrm9) || !instance_exists(self))
#define orandom(_num)                                                                   		return  random_range(-_num, _num);
#define chance(_numer, _denom)                                                          		return  random(_denom) < _numer;
#define chance_ct(_numer, _denom)                                                       		return  random(_denom) < _numer * current_time_scale;
#define angle_lerp_ct(_ang1, _ang2, _num)                                               return  _ang2 + (angle_difference(_ang1, _ang2) * power(1 - _num, current_time_scale));
#define enemy_walk(_dir, _num)                                                                  direction = _dir; walk = _num; if(speed < friction) speed = friction;
#define enemy_face(_dir)                                                                        _dir = ((_dir % 360) + 360) % 360; if(_dir < 90 || _dir > 270) right = 1; else if(_dir > 90 && _dir < 270) right = -1;
#define enemy_look(_dir)                                                                        _dir = ((_dir % 360) + 360) % 360; if(_dir < 90 || _dir > 270) right = 1; else if(_dir > 90 && _dir < 270) right = -1; if('gunangle' in self) gunangle = _dir;
#define enemy_target(_x, _y)                                                            		target = (instance_exists(Player) ? instance_nearest(_x, _y, Player) : ((instance_exists(target) && target >= 0) ? target : noone)); return (target != noone);
#define BasicEnemy_draw                             											draw_sprite_ext(sprite_index,image_index,x,y,image_xscale * right, image_yscale, image_angle, image_blend, image_alpha);
#define GunEnemy_draw                               											if gunangle < 180{ draw_sprite_ext(spr_weap,0,x + lengthdir_x(-wkick,gunangle), y + lengthdir_y(-wkick, gunangle), 1, right, gunangle, image_blend, image_alpha);} draw_sprite_ext(sprite_index,image_index,x,y,image_xscale * right, image_yscale, image_angle, image_blend, image_alpha); if gunangle >= 180{ draw_sprite_ext(spr_weap,0,x + lengthdir_x(-wkick,gunangle), y + lengthdir_y(-wkick, gunangle), 1, right, gunangle, image_blend, image_alpha);}
#define MeleeEnemy_draw																			if(gunangle <= 180) draw_weapon(spr_weap, 0, x, y, gunangle, wepangle, wkick, 1, image_blend, image_alpha); image_xscale *= right; draw_self(); image_xscale /= right; if(gunangle >  180) draw_weapon(spr_weap, 0, x, y, gunangle, wepangle, wkick, 1, image_blend, image_alpha);
#define StandardDrops                           												pickup_drop(40, 10, 2);


#define nothing
//not one thing!

#define enemy_step
	 // Alarms:
	if("on_alrm0" in self and alarm0_run) exit;
	if("on_alrm1" in self and alarm1_run) exit;
	
	 // Movement:
	if(walk > 0){
		walk -= current_time_scale;
		speed += walkspeed * current_time_scale;
	}
	if(speed > maxspeed){
		speed = maxspeed;
	}
	
	 // Animate:
	sprite_index = enemy_sprite;
	
#define Enemy_hurt(_dmg, _spd, _dir)
	sprite_index = spr_hurt;
	image_index  = 0;
	
	sound_play_hit(snd_hurt, 0.3);
	motion_add(_dir, _spd);
	
	nexthurt   = current_frame + 6;
	my_health -= _dmg;

//Snatched from Lib
#define corpse_drop // inst, direction=inst.direction, speed=inst.speed
	/*
		Creates a corpse based on the given hitme's variables
		
		Args:
			inst      - The hitme whose corpse will be dropped
			direction - The corpse's direction, defaults to the hitme's direction
			speed     - The corpse's base speed, defaults to the hitme's speed
	*/
	
	with(argument[0]){
		with(instance_create(x, y, Corpse)){
			size         = other.size;
			sprite_index = other.spr_dead;
			image_xscale = (("right" in other) ? other.right : other.image_xscale);
			direction    = ((argument_count > 1) ? argument[1] : other.direction);
			speed        = ((argument_count > 2) ? argument[2] : other.speed);
			
			 // Non-Props:
			if(!instance_is(other, prop) && instance_is(other, hitme)){
				mask_index = other.mask_index;
				speed += max(0, -other.my_health / 5);
				speed += 8 * skill_get(mut_impact_wrists) * instance_is(other, enemy);
			}
			
			 // Clamp Speed:
			speed = min(speed, 16);
			if(size > 0){
				speed /= size;
			}
			
			return self;
		}
	}
	
	return noone;
	

//Snatched from TE
#define draw_weapon(_sprite, _image, _x, _y, _angle, _angleMelee, _kick, _flip, _blend, _alpha)
	/*
		Drawing weapon sprites
		
		Ex:
			draw_weapon(sprBanditGun, gunshine, x, y, gunangle, 0, wkick, right, image_blend, image_alpha)
			draw_weapon(sprPipe, 0, x, y, gunangle, wepangle, wkick, wepflip, image_blend, image_alpha)
	*/
	
	 // Melee Offset:
	if(_angleMelee != 0){
		_angle += _angleMelee * (1 - (_kick / 20));
	}
	
	 // Kick:
	if(_kick != 0){
		_x -= lengthdir_x(_kick, _angle);
		_y -= lengthdir_y(_kick, _angle);
	}
	
	 // Draw:
	draw_sprite_ext(_sprite, _image, _x, _y, 1, _flip, _angle, _blend, _alpha);
	
#define sound_play_hit_ext(_sound, _pitch, _volume)
	/*
		'sound_play_hit()' distance-based sound, but with pitch and volume arguments
	*/
	
	var _snd = sound_play_hit(_sound, 0);
	
	sound_pitch(_snd, _pitch);
	sound_volume(_snd, audio_sound_get_gain(_snd) * _volume);
	
	return _snd;
	
